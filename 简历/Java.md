###### 谈谈你对Java平台的理解
Java本身是一种面向对象的语言，最显著的特性包含亮点，一是所谓的“书写一次，到处运行”，能够非常容易的获取跨平台特性，二是垃圾收集机制，相对于C++衍生来的语言，通过垃圾手机机制，程序员不需要考虑内存的分配和回收。
日常接触的JRE，也就是Java运行环境。JDK提供了更多工具，比如编译器，诊断工具。
首先Java文件通过Javac编译成为字节码，然后再运行时，通过Java虚拟机内嵌的解释器将字节码转换为最终的机器码。
###### Exception和Error有什么区别
Exception和Error都集成了Throwable类，在Java中只有Throwable类型的实例可以被抛出或者捕获。
Exception是程序运行中，可以预料的意外情况，应该被捕获去处理。Error是在正常情况下，不太可能出现的情况，觉得多数的Error都会导致程序的崩溃，不可恢复，比如常见的OutOfMemoryError
Exception又分为可检查异常和不可检查异常。可检查异常必须在源代码中显示的捕获处理。不可检查异常是运行时的异常，类似空指针、数组越界等，通常是可以编码避免的逻辑错误。
###### final、finally、finalize区别
final可以用来修饰类、方法、变量，final修饰的类不可以继承扩展、final修饰的方法不可以重写、final修饰的变量不可以修改。
finally是保证代码一定要执行的一种机制，一般是try catch finally，进行类似jdbc的关闭、流关闭等。
finalize是基础类Object的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定的功能，Jdk9已标记为过时。
###### 强引用、软引用、弱引用、幻想引用的区别
不同类型的引用，表现为对象不同的可达性和对垃圾收集的影响。
强引用：就是常见的普通对象引用，只要强引用指向一个对象，表明此对象还或者，垃圾收集不会碰触这类引用。对于一个普通对象，如果没有其他的引用关系，就可以被垃圾收集了。
软引用：是一种相对强引用较弱的引用，只有当jvm判断内存不足时，也就是在抛出OutOfMemoryError之前，会回收软引用，软引用用来实现内存敏感的缓存。
弱引用：并不能是对象豁免垃圾收集，仅仅提供一种访问在弱引用状态下对象的途径，比如，维护一种非强制的映射关系。
幻想引用（虚引用）：幻想引用仅仅提供一种确保对象finalize以后，做某些事情的机制。
###### String、StringBuffer、StringBuilder有什么区别
String是Java语言中非常重要和基础的类，封装了字符串的构造和操作。它是典型的Immutable类型的，String class被final修饰，所有的属性也是final，导致它不可以被修改，每次操作都会产生新的字符串，对性能会产生影响。
StringBuffer是为解决String不可变而提供的一个类，可以用append进行字符串的拼接。它的本质是一个线程安全的可修改字符序列，底层实现为chat数组，后续改为byte数组，所有的方法都加上了synchronized修饰，保证了线程安全，则性能方面开销就多了。
StringBuilder与StringBuffer没有本质区别，去掉了线程安全的部分。
###### 谈谈 Java 反射机制，动态代理是基于什么原理
反射是Java语言提供的一种基础功能，它提供程序在运行时自省的能力。通过反射可以获取类的属性和方法，调用方法或构造对象，甚至修改类定义。
动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制完成的，比如包装RPC调用、面向切面编程AOP。
实现动态代理的方式有很多，比如JDK自身提供的动态代理，就是利用上面的反射机制。还有其他的方式，如更高性能的字节码操作技术，类似ASM、cglib等。
###### int 和 Integer 有什么区别
int是我们常说的整型，java中的八种基础类型之一。
Integer是int类型的包装类，它有一个int类型的字段存储数据，提供了基本操作。Java5提供了自动装箱、自动拆箱，int和Integer可以相互转换。
关于Integer的缓存，Java5提供了静态工厂方法valueOf，在调用它的时候会利用一个缓存机制，默认的缓存为-128-127.
###### Vector、ArrayList、LinkedList 有何区别
这三者都是先了集合框架list，提供了添加、删除、定位等功能，提供了迭代器遍历其内容。
Vector是Java早期实现的集合，线程安全的，内部基于数组实现，性能较低。扩容时需要新建一个原有两倍的数组，将旧的集合拷贝到新的上去。
ArrayList也是动态数组实现的，它在扩容时增加50%。
LinkedList底层是双向链表实现的。
###### 对比 Hashtable、HashMap、TreeMap 有什么不同
这三者都是以键值对形式存储和操作的数据容器。
Hashtable是Java早期实现的一个哈希表同步的容器，不支持null键和值。
HashMap不是同步的，应用更加广泛。数组+链表+二叉树实现的。（散列因子0.75）
TreeMap是基于红黑树的一种顺序访问的map实现。它的操作都是O（log（n））时间复杂度。
###### 线程安全的队列
Java提供了不同层面的线程安全支持，传统集合框架内部，除了Hashtable等synchronized实现的同步内容，还提供了同步包装类，我们可以调用Collections工具类提供的包装方法实现线程安全，但这种粒度大，性能差。
Java也提供了各种并发容器，如ConcurrentHashMap、CopyOnWriteArrayList，各种线程安全的队列，如ArrayBlockingQueue、SynchronousQueue，很多底层都是采用CAS思想进行处理。
###### NIO 如何实现多路复用
io分为两种，一种是传统的io，基础流模型实现的。另一种就是Nio，提供了Channel、Selector、Buffer。在Java7，Nio进一步改进，为Aio。
比如Selector可以检测到注册在上面的Channel，基于底层操作系统的机制，比如Linux上依赖于epoll，进而实现了单线程对多个Channel的高效管理。
Buffer用于文件拷贝中，普通io用于文件读写是，先在内核态将数据从磁盘读取到内核缓存，在切换到用户态将内核缓存读取到用户缓存，写入操作类似相反。而Nio则不需要用户态参与，省去了上下文的切换和不必要的内存拷贝。
###### 接口和抽象类有什么区别
接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到Api的定义和分离实现的目的。接口不能实例化。不能包含任何成员变量。接口用interface修饰，使用implements实现
抽象类是不能实例化的类，用abstract修饰，主要目的是代码重用，使用extends继承
###### 设计模式
创建型模式，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。
结构型模式，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。
行为型模式，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。
BeanFactory和ApplicationContext应用了工厂模式。
在 Bean 的创建中，Spring 也为不同 scope 定义的对象，提供了单例和原型等模式实现。
AOP 领域则是使用了代理模式、装饰器模式、适配器模式等。
各种事件监听器，是观察者模式的典型应用。
类似 JdbcTemplate 等则是应用了模板模式。