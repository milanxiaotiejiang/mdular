###### 谈谈你对Java平台的理解
Java本身是一种面向对象的语言，最显著的特性包含亮点，一是所谓的“书写一次，到处运行”，能够非常容易的获取跨平台特性，二是垃圾收集机制，相对于C++衍生来的语言，通过垃圾手机机制，程序员不需要考虑内存的分配和回收。
日常接触的JRE，也就是Java运行环境。JDK提供了更多工具，比如编译器，诊断工具。
首先Java文件通过Javac编译成为字节码，然后再运行时，通过Java虚拟机内嵌的解释器将字节码转换为最终的机器码。
###### Exception和Error有什么区别
Exception和Error都集成了Throwable类，在Java中只有Throwable类型的实例可以被抛出或者捕获。
Exception是程序运行中，可以预料的意外情况，应该被捕获去处理。Error是在正常情况下，不太可能出现的情况，觉得多数的Error都会导致程序的崩溃，不可恢复，比如常见的OutOfMemoryError
Exception又分为可检查异常和不可检查异常。可检查异常必须在源代码中显示的捕获处理。不可检查异常是运行时的异常，类似空指针、数组越界等，通常是可以编码避免的逻辑错误。
###### final、finally、finalize区别
final可以用来修饰类、方法、变量，final修饰的类不可以继承扩展、final修饰的方法不可以重写、final修饰的变量不可以修改。
finally是保证代码一定要执行的一种机制，一般是try catch finally，进行类似jdbc的关闭、流关闭等。
finalize是基础类Object的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定的功能，Jdk9已标记为过时。
###### 强引用、软引用、弱引用、幻想引用的区别
不同类型的引用，表现为对象不同的可达性和对垃圾收集的影响。
强引用：就是常见的普通对象引用，只要强引用指向一个对象，表明此对象还或者，垃圾收集不会碰触这类引用。对于一个普通对象，如果没有其他的引用关系，就可以被垃圾收集了。
软引用：是一种相对强引用较弱的引用，只有当jvm判断内存不足时，也就是在抛出OutOfMemoryError之前，会回收软引用，软引用用来实现内存敏感的缓存。
弱引用：并不能是对象豁免垃圾收集，仅仅提供一种访问在弱引用状态下对象的途径，比如，维护一种非强制的映射关系。
幻想引用（虚引用）：幻想引用仅仅提供一种确保对象finalize以后，做某些事情的机制。
###### String、StringBuffer、StringBuilder有什么区别
String是Java语言中非常重要和基础的类，封装了字符串的构造和操作。它是典型的Immutable类型的，String class被final修饰，所有的属性也是final，导致它不可以被修改，每次操作都会产生新的字符串，对性能会产生影响。
StringBuffer是为解决String不可变而提供的一个类，可以用append进行字符串的拼接。它的本质是一个线程安全的可修改字符序列，底层实现为chat数组，后续改为byte数组，所有的方法都加上了synchronized修饰，保证了线程安全，则性能方面开销就多了。
StringBuilder与StringBuffer没有本质区别，去掉了线程安全的部分。
###### 谈谈 Java 反射机制，动态代理是基于什么原理
反射是Java语言提供的一种基础功能，它提供程序在运行时自省的能力。通过反射可以获取类的属性和方法，调用方法或构造对象，甚至修改类定义。
动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制完成的，比如包装RPC调用、面向切面编程AOP。
实现动态代理的方式有很多，比如JDK自身提供的动态代理，就是利用上面的反射机制。还有其他的方式，如更高性能的字节码操作技术，类似ASM、cglib等。
###### int 和 Integer 有什么区别
int是我们常说的整型，java中的八种基础类型之一。
Integer是int类型的包装类，它有一个int类型的字段存储数据，提供了基本操作。Java5提供了自动装箱、自动拆箱，int和Integer可以相互转换。
关于Integer的缓存，Java5提供了静态工厂方法valueOf，在调用它的时候会利用一个缓存机制，默认的缓存为-128-127.
###### Vector、ArrayList、LinkedList 有何区别
这三者都是先了集合框架list，提供了添加、删除、定位等功能，提供了迭代器遍历其内容。
Vector是Java早期实现的集合，线程安全的，内部基于数组实现，性能较低。扩容时需要新建一个原有两倍的数组，将旧的集合拷贝到新的上去。
ArrayList也是动态数组实现的，它在扩容时增加50%。
LinkedList底层是双向链表实现的。
###### 对比 Hashtable、HashMap、TreeMap 有什么不同
这三者都是以键值对形式存储和操作的数据容器。
Hashtable是Java早期实现的一个哈希表同步的容器，不支持null键和值。
HashMap不是同步的，应用更加广泛。数组+链表+二叉树实现的。（散列因子0.75）
TreeMap是基于红黑树的一种顺序访问的map实现。它的操作都是O（log（n））时间复杂度。
###### 线程安全的队列
Java提供了不同层面的线程安全支持，传统集合框架内部，除了Hashtable等synchronized实现的同步内容，还提供了同步包装类，我们可以调用Collections工具类提供的包装方法实现线程安全，但这种粒度大，性能差。
Java也提供了各种并发容器，如ConcurrentHashMap、CopyOnWriteArrayList，各种线程安全的队列，如ArrayBlockingQueue、SynchronousQueue，很多底层都是采用CAS思想进行处理。
###### NIO 如何实现多路复用
io分为两种，一种是传统的io，基础流模型实现的。另一种就是Nio，提供了Channel、Selector、Buffer。在Java7，Nio进一步改进，为Aio。
比如Selector可以检测到注册在上面的Channel，基于底层操作系统的机制，比如Linux上依赖于epoll，进而实现了单线程对多个Channel的高效管理。
Buffer用于文件拷贝中，普通io用于文件读写是，先在内核态将数据从磁盘读取到内核缓存，在切换到用户态将内核缓存读取到用户缓存，写入操作类似相反。而Nio则不需要用户态参与，省去了上下文的切换和不必要的内存拷贝。
###### 接口和抽象类有什么区别
接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到Api的定义和分离实现的目的。接口不能实例化。不能包含任何成员变量。接口用interface修饰，使用implements实现
抽象类是不能实例化的类，用abstract修饰，主要目的是代码重用，使用extends继承
###### 设计模式
创建型模式，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。
结构型模式，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。
行为型模式，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。
BeanFactory和ApplicationContext应用了工厂模式。
在 Bean 的创建中，Spring 也为不同 scope 定义的对象，提供了单例和原型等模式实现。
AOP 领域则是使用了代理模式、装饰器模式、适配器模式等。
各种事件监听器，是观察者模式的典型应用。
类似 JdbcTemplate 等则是应用了模板模式。
###### synchronized和ReentrantLock有什么区别
synchronized 是 Java 内建的同步机制，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。
Java5 之前，synchronized仅有同步的手段，synchronized可以用来修饰方法，也可以放在指定的代码块中，本质上synchronized方法等同于把方法全部语句用synchronized块包起来。
ReentrantLock，再入锁，通过直接调用lock()方法获取锁。可以使用fairness定义公平性。编码中必须调用unlock()显示的释放锁。
###### synchronized底层如何实现？什么是锁的升级、降级
synchronized代码块是一对monitorenter/monitorexit指令实现的，Monitor对象是同步的基本实现单元。
在Java6 之前Monitor的实现完全是依赖操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。
现代的JDK中，提供了三种不同的Monitor实现，偏斜锁、轻量级锁、重量级锁。
锁的升级、降级是JVM检测到不同的竞争状态时，会自动切换合适的锁实现。
当没有竞争时，默认使用偏斜锁，JVM会利用CAS操作，在对象的Mark Word部分设置线程ID，以标识对象偏向于此线程，所以并不涉及真正的互斥锁。大部分对象的生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。
如果有另外的线程试图尝试锁定某个已经被偏斜过的对象时，JVM就会撤销偏斜锁，切换为轻量级锁。轻量级锁依赖CAS操作Mark Word试图获取锁，如果重试成功，就使用轻量级锁，否则，则切换为重量级锁。
###### Java 并发包
CountDownLatch：允许一个或多个线程等待某些操作完成
CyclicBarrier：允许多个线程等待到达某种状态
Semaphore：限制同时进行工作的线程数量
ConcurrentHashMap、ConcurrentLinkedQueue、ConcurrentSkipListMap：有序的。（Concurrent类型是基于锁实现的，依赖于 Unsafe ）
CopyOnWriteArrayList：通过类似快照机制，实现线程安全的动态数组
BlockingQueue等等（LinkedBlockingQueue、ArrayBlockingQueue、SynchronousQueue）（ReentrantLock）（睿恩吹）
Executor 框架
###### AtomicInteger底层实现原理
AtomicInteger 是对int类型的一个封装，提供了原子访问和操作，其原子性操作基于CAS技术。
CAS：表征的是一些列操作集合，获取当前值，进行一些运算，利用CAS指令试图进行更新。如果当前数值未变，代表没有其他线程没有进行并发修改，则更新成功。否则，要么进行重试，要么返回失败。
依赖于 Unsafe 提供的一些底层能力，进行底层操作，以 volatile 的 value 字段，记录数值，保证可见性。
###### 类加载过程
三个步骤：加载、链接、初始化
加载：将Java字节码从不同的数据源读到JVM中，并映射为JVM认可的数据结构（Class结构），
链接：分为三步骤（验证、准备、解析）
    验证：验证字节信息是否符合JVM规范
    准备：创建类或接口中的静态变量
    解析：将常量池中的符号引用替换为直接引用
初始化：真正执行类初始化，包括静态字段的赋值动作，执行类定义中的静态初始化内的逻辑。
###### 双亲委派模型
当前类加载器试图加载某个类的时候，除非父加载器找不到相应的类型，否则尽量将这个任务代理给当前类加载器的父加载器执行。使用双亲委派模型的作用是避免重复的类加载。
###### JVM 内存区域的划分
程序计数器：每个线程都有自己的程序计数器，且任何时间都只有一个方法在执行，就是所谓的当前方法。程序计数器会存储当前正在执行的方法的JVM指令地址。
虚拟机栈：每个线程创建时都会创建一个虚拟机栈，内部保存一个个栈帧，对应一个个的方法。栈帧存储着局部变量表、操作数栈、动态链接、方法正常或异常退出的定义。
堆：Java实体对象，垃圾收集重点区域，新生代、老年代。
方法区：所有线程共享的一块区域，存储元数据，如：类结构信息，以及运行时常量池、字段、方法代码等（以前的永久代）
运行时常量池：方法区的一部分，存储类文件结构。
本地方法栈：每个线程都会创建一个